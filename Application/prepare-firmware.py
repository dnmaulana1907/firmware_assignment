from hashlib import sha256
import binascii
import sys
import os

# --- AUTOMATIC PATH CONFIGURATION ---
# Get the directory where this script is located
BASE_DIR = os.path.dirname(os.path.abspath(__file__))

# Input file: The binary generated by STM32CubeIDE (adjust filename if necessary)
output_bin = os.path.join(BASE_DIR, "Debug", "Application.bin")

# Output file: The final processed binary with Header/CRC/SHA
output_final = os.path.join(BASE_DIR, "Debug", "PB_Application.bin")

# Header offset size (512 bytes)
BUFFER_FOR_VER_N_SHA = 0x200

# --- UTILITY FUNCTIONS ---

def get_len_file(filepath):
    """Returns the total size of the file in bytes."""
    with open(filepath, "rb") as f:
        return len(f.read())

def get_data_from_file(filepath, size, offset):
    """Reads a specific chunk of data from a file given an offset and size."""
    if not os.path.exists(filepath):
        print(f"ERROR: File {filepath} not found!")
        sys.exit(1)
    with open(filepath, "rb") as f:
        f.seek(offset)
        return f.read(size)

def convert_to_array(origin_buffer):
    """Converts bytes/buffer to a list of integers."""
    return [int(b) for b in origin_buffer]

def fill_buff_with_0xff(length):
    """Creates a buffer filled with 0xFF padding."""
    return bytearray([0xFF] * length)

def convert_string_to_array(origin_buffer, base, length, count_shift):
    """Converts hex strings to an integer array with optional bit shifting."""
    array_result = []
    for i in range(length):
        array_hex = int(origin_buffer[i], base)
        array_result.append(array_hex >> count_shift)
    return array_result

def get_crc_bytearray(crc_hex):
    """Formats CRC hex string into a 4-byte bytearray."""
    crc_padding = crc_hex.zfill(8)
    crc_hexstring = [crc_padding[i:i+2] for i in range(0, 8, 2)]
    return bytearray(convert_string_to_array(crc_hexstring, 16, 4, 0))

def get_file_size_bytes(size):
    """Converts file size integer into a 4-byte array representation."""
    hex_size = format(size, '08x')
    size_string = [hex_size[i:i+2] for i in range(0, 8, 2)]
    return convert_string_to_array(size_string, 16, 4, 0)

def sha_loop_calculation(sha_buffer, count_loop):
    """Performs iterative SHA256 hashing based on version numbers."""
    current_buffer = sha_buffer
    for i in range(count_loop):
        sha2_hex = sha256(current_buffer).hexdigest()
        sha2_list = [sha2_hex[j:j+2] for j in range(0, 64, 2)]
        list_sha = convert_string_to_array(sha2_list, 16, 32, 0)
        current_buffer = bytearray(list_sha)
    return current_buffer

def bx_authentication(crc, version):
    """Generates authentication key using CRC and App Version."""
    # Step 1: Initial SHA256 of the CRC
    sha1_hex = sha256(crc).hexdigest()
    hash_hexstring = [sha1_hex[i:i+2] for i in range(0, 64, 2)]
    
    # Step 2: Bit shift based on Major Version
    count_shift = version[0] % 2
    hash_with_shift = convert_string_to_array(hash_hexstring, 16, 32, count_shift)
    
    # Step 3: Iterative hashing based on Minor Version
    count_loop = 1 + (version[1] % 3)
    return sha_loop_calculation(bytearray(hash_with_shift), count_loop)

# --- MAIN EXECUTION ---

print("--- STARTING POST-BUILD PROCESSING ---")
print(f"Target file: {output_bin}")

# 1. Get Application Version (First 3 bytes of the binary)
buffer_version = get_data_from_file(output_bin, 4, 0)
version_in_array = convert_to_array(buffer_version)
print(f"Detected Version: {version_in_array}")

# 2. Calculate CRC32 of the actual application data
apps_length = get_len_file(output_bin)
data_to_crc = get_data_from_file(output_bin, (apps_length - BUFFER_FOR_VER_N_SHA), BUFFER_FOR_VER_N_SHA)

calculate_crc = binascii.crc32(data_to_crc) & 0xFFFFFFFF
crc_hex = format(calculate_crc, '08x')
crc_byte_array = get_crc_bytearray(crc_hex)
print(f"Application CRC32: 0x{crc_hex.upper()}")

# 3. Calculate Application Size in Bytes and KB
app_size_val = apps_length - BUFFER_FOR_VER_N_SHA
app_size_kb = app_size_val / 1024
apps_size_bytes = bytearray(get_file_size_bytes(app_size_val))
print(f"Application Size: {app_size_val} bytes ({app_size_kb:.2f} KB)") 

# 4. Generate Authentication Key (SHA-based)
auth_key = bx_authentication(crc_byte_array, version_in_array)
print(f"Authentication Key: {auth_key.hex()}")

# 5. Assemble Final Binary
# Structure: [Version(4)] [Size(4)] [AuthKey(32)] [Padding(FF)] [AppData]
fill_len = BUFFER_FOR_VER_N_SHA - (len(buffer_version) + len(apps_size_bytes) + len(auth_key))
fill_buff = fill_buff_with_0xff(fill_len)

final_payload = b''.join([buffer_version, apps_size_bytes, auth_key, fill_buff, data_to_crc])

# 6. Save the Processed Binary
with open(output_final, "wb") as f:
    f.write(final_payload)
print("---------------------------------------")